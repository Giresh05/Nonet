<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Sensor & Anomaly Dashboard</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Local Plotly.js -->
    <script src="/static/lib/plotly-2.30.0.min.js"></script>
    <style>
        /* Custom CSS for font and scrollbar */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        :root {
            --bg-color: #f0f2f5; /* Light gray background */
            --text-color: #333;
            --card-bg: #fff;
            --nav-bg: #1e3a8a; /* Dark blue for nav */
            --nav-text: white;
            --nav-hover-bg: #2563eb; /* Blue-600 */
            --nav-active-text: #fcd34d; /* Amber-300 */
        }
        body.dark-mode {
            --bg-color: #1c1e21;
            --text-color: #f0f0f0;
            --card-bg: #2a2d31;
            --nav-bg: #1a202c; /* Darker for dark mode nav */
            --nav-text: #cbd5e1;
            --nav-hover-bg: #2d3748;
            --nav-active-text: #fcd34d;
        }

        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e2e8f0; /* Tailwind gray-200 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* Tailwind gray-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* Tailwind gray-500 */
        }
        /* Table styling */
        .node-table th, .node-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0; /* Tailwind gray-200 */
        }
        .node-table th {
            background-color: #f1f5f9; /* Tailwind slate-100 */
            font-weight: 600;
            color: #475569; /* Tailwind slate-600 */
            font-size: 0.875rem; /* sm text */
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .node-table tbody tr:hover {
            background-color: #f8fafc; /* Tailwind gray-50 */
        }
        .node-table tbody tr:last-child td {
            border-bottom: none;
        }
        /* Theme toggle button styling */
        #themeIcon {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--nav-text); /* Matches nav text color */
            transition: color 0.3s ease;
            z-index: 10; /* Ensure it's above other elements */
        }
    </style>
</head>
<body class="bg-[var(--bg-color)] text-[var(--text-color)] min-h-screen flex flex-col items-center">
    <button id="themeIcon">ðŸŒ™</button>

    <!-- Navigation Bar -->
    <nav class="bg-[var(--nav-bg)] p-4 shadow-md flex justify-center relative w-full">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <div class="text-2xl font-bold text-[var(--nav-text)] mb-2 sm:mb-0">NoNet</div>
            <div class="flex space-x-4">
                <a href="/" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">Home</a>
                <a href="/dashboard" class="text-[var(--nav-active-text)] font-semibold hover:text-[var(--nav-text)] py-2 px-3 rounded-md transition duration-300 bg-[var(--nav-hover-bg)]">Dashboard</a>
                <a href="/map" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">Map</a>
                <a href="/about" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">About</a>
            </div>
        </div>
    </nav>

    <!-- Header Section -->
    <header class="w-full max-w-6xl text-center mb-8 p-4 sm:p-6">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-700 mb-2 drop-shadow-lg">
            ESP32 Sensor & Anomaly Dashboard
        </h1>
        <p class="text-lg text-gray-600">Live monitoring and anomaly detection of environmental sensors</p>
    </header>

    <!-- Main Content Area -->
    <main class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-3 gap-6 p-4 sm:p-6">

        <!-- Overall Sensor Data Section (Left/Top) -->
        <section class="lg:col-span-2 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Overall Sensor Data (Average)</h2>
            <div id="overallSensorChart" class="w-full h-80 sm:h-96 bg-gray-50 rounded-lg border border-gray-200">
                <!-- Plotly chart will be rendered here -->
            </div>
            <div id="overallSensorMetrics" class="grid grid-cols-2 sm:grid-cols-3 gap-4 mt-6 text-center">
                <!-- Live metrics will be updated here by JavaScript -->
            </div>
        </section>

        <!-- Status & Last Update Section (Right/Top) -->
        <section class="lg:col-span-1 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200 flex flex-col justify-between">
            <div>
                <h2 class="text-2xl font-bold text-gray-800 mb-4">System Status</h2>
                <div class="flex items-center mb-4">
                    <span class="relative flex h-3 w-3 mr-3">
                        <span id="connectionStatusPulse" class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                        <span id="connectionStatusDot" class="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
                    </span>
                    <p id="connectionMessage" class="text-lg font-medium text-green-700">Connected to Backend</p>
                </div>
                <p class="text-md text-gray-600 mb-2">Last data update:</p>
                <p id="lastUpdateTime" class="text-lg font-semibold text-blue-600">N/A</p>
            </div>
            <div class="mt-6 pt-4 border-t border-gray-200">
                <h3 class="text-xl font-bold text-gray-800 mb-3">Active Nodes</h3>
                <div id="activeNodesList" class="max-h-40 overflow-y-auto pr-2">
                    <!-- Active nodes will be listed here by JavaScript -->
                    <p class="text-gray-500">No nodes detected yet...</p>
                </div>
            </div>
            
            <!-- Mode Control Section -->
            <div class="mt-6 pt-4 border-t border-gray-200">
                <h3 class="text-xl font-bold text-gray-800 mb-3">ESP32 Mode Control</h3>
                <p id="currentModeDisplay" class="text-lg font-semibold text-purple-700 mb-4">Current Mode: Unknown</p>
                <div class="flex flex-col space-y-3">
                    <button id="dataCollectionBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                        Set Data Collection Mode
                    </button>
                    <button id="standbyBtn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                        Set Standby Mode
                    </button>
                </div>
                <div id="modeStatusMessage" class="mt-4 text-center text-sm font-medium"></div>
            </div>
        </section>

        <!-- Overall Anomaly Data Section -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Overall Anomaly Scores (Average)</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div id="overallIsoScoreChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div id="overallRiverScoreChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div id="overallWarningLevelChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
            </div>
            <div id="overallAnomalyMetrics" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mt-6 text-center">
                <!-- Live anomaly metrics will be updated here by JavaScript -->
            </div>
        </section>

        <!-- Current Node Data Table -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Current Node Data Table</h2>
            <div class="overflow-x-auto">
                <table id="nodeDataTable" class="min-w-full bg-white rounded-lg node-table">
                    <thead>
                        <tr>
                            <th>Node ID</th>
                            <th>Timestamp</th>
                            <th>MAC Address</th>
                            <th>Rain</th>
                            <th>Soil</th>
                            <th>Vibration (g)</th>
                            <th>Tilt (Â°)</th>
                            <th>IF Score</th>
                            <th>HST Score</th>
                            <th>Warning Level</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be dynamically populated here -->
                        <tr><td colspan="10" class="text-center text-gray-500 py-4">No node data available.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- CSV Logging Controls -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">CSV Logging Controls</h2>
            <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4 items-center justify-center">
                <button id="startCsvBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Start CSV Logging
                </button>
                <button id="stopCsvBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Stop CSV Logging
                </button>
                <button id="downloadCsvBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Download CSV
                </button>
            </div>
            <div id="csvStatusMessage" class="mt-4 text-center text-sm font-medium"></div>
            <p id="csvLoggingStatus" class="mt-2 text-center text-lg font-semibold text-gray-600">CSV Logging: Inactive</p>
        </section>

        <!-- Individual Node Data Section (Bottom) -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Individual Node Data & Anomaly Scores</h2>
            <div id="individualNodesContainer" class="">
                <!-- Individual node charts will be dynamically added here by JavaScript -->
                <div class="p-4 bg-gray-50 rounded-lg text-center text-gray-500 border border-gray-200">
                    No individual node data available yet.
                </div>
            </div>
        </section>

    </main>

    <!-- JavaScript for fetching data and updating charts -->
    <script>
        // Configuration for the data fetching
        const API_URL = '/api/live_data'; // Endpoint for your Flask backend
        const SET_MODE_API_URL = '/api/set_mode'; // Endpoint for setting ESP32 mode
        const START_CSV_API_URL = '/api/start_csv_logging';
        const STOP_CSV_API_URL = '/api/stop_csv_logging';
        const DOWNLOAD_CSV_API_URL = '/api/download_csv';
        const FETCH_INTERVAL_MS = 1000; // Fetch data every 1 second
        const MAX_DATA_POINTS = 60; // Keep last 60 seconds of data for charts

        // Data storage objects
        let overallSensorData = { timestamps: [], rain: [], soil: [], vibration: [], iso_score: [], river_score: [], warning_level_numerical: [] };
        let individualNodeData = {};

        // DOM elements
        const overallSensorChartDiv = document.getElementById('overallSensorChart');
        const overallSensorMetricsDiv = document.getElementById('overallSensorMetrics');
        const overallIsoScoreChartDiv = document.getElementById('overallIsoScoreChart');
        const overallRiverScoreChartDiv = document.getElementById('overallRiverScoreChart');
        const overallWarningLevelChartDiv = document.getElementById('overallWarningLevelChart');
        const overallAnomalyMetricsDiv = document.getElementById('overallAnomalyMetrics');
        const individualNodesContainer = document.getElementById('individualNodesContainer');
        const lastUpdateTimeSpan = document.getElementById('lastUpdateTime');
        const connectionStatusDot = document.getElementById('connectionStatusDot');
        const connectionStatusPulse = document.getElementById('connectionStatusPulse');
        const connectionMessage = document.getElementById('connectionMessage');
        const activeNodesListDiv = document.getElementById('activeNodesList');
        const dataCollectionBtn = document.getElementById('dataCollectionBtn');
        const standbyBtn = document.getElementById('standbyBtn');
        const currentModeDisplay = document.getElementById('currentModeDisplay');
        const modeStatusMessage = document.getElementById('modeStatusMessage');
        const nodeDataTableBody = document.querySelector('#nodeDataTable tbody');
        const startCsvBtn = document.getElementById('startCsvBtn');
        const stopCsvBtn = document.getElementById('stopCsvBtn');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const csvStatusMessage = document.getElementById('csvStatusMessage');
        const csvLoggingStatus = document.getElementById('csvLoggingStatus');

        // Plotly chart instances
        let overallSensorChartInstance;
        let overallIsoScoreChartInstance;
        let overallRiverScoreChartInstance;
        let overallWarningLevelChartInstance;
        const individualChartInstances = {};

        /**
         * Initializes a chart with a common layout.
         */
        function initializeChart(div, data, layoutConfig) {
            const baseLayout = {
                xaxis: { title: 'Time', showgrid: true, linecolor: '#cbd5e1', linewidth: 1 },
                margin: { l: 50, r: 20, t: 50, b: 50 },
                hovermode: 'x unified',
                responsive: true,
                paper_bgcolor: 'var(--card-bg)',
                plot_bgcolor: 'var(--card-bg)',
                font: { family: 'Inter, sans-serif', color: 'var(--text-color)' },
                legend: { x: 0, y: 1.15, orientation: 'h', bgcolor: 'rgba(255,255,255,0)', bordercolor: 'rgba(255,255,255,0)' }
            };
            const finalLayout = { ...baseLayout, ...layoutConfig };
            Plotly.newPlot(div, data, finalLayout, { displayModeBar: false, responsive: true });
        }

        /**
         * Initializes all the main dashboard charts.
         */
        function initializeAllCharts() {
            // Overall Sensor Chart
            initializeChart(overallSensorChartDiv, [
                { x: [], y: [], mode: 'lines', name: 'Rain', line: { color: '#3b82f6', width: 2 } },
                { x: [], y: [], mode: 'lines', name: 'Soil Moisture', line: { color: '#22c55e', width: 2 } },
                { x: [], y: [], mode: 'lines', name: 'Vibration (g)', line: { color: '#ef4444', width: 2 } }
            ], {
                title: { text: 'Overall Sensor Trends', font: { size: 18, color: '#334155' }, y: 0.99 },
                yaxis: { title: 'Value', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0, 4095] }
            });
            overallSensorChartInstance = overallSensorChartDiv;

            // Overall Anomaly Charts
            const anomalyLayout = { yaxis: { title: 'Score', showgrid: true, linecolor: '#cbd5e1', linewidth: 1 } };
            initializeChart(overallIsoScoreChartDiv, [{ x: [], y: [], mode: 'lines', name: 'IF Score', line: { color: '#8b5cf6', width: 2 } }], 
                { ...anomalyLayout, title: { text: 'Overall IF Score', font: { size: 16, color: '#334155' } }, yaxis: {...anomalyLayout.yaxis, range: [-0.5, 0.5]} });
            overallIsoScoreChartInstance = overallIsoScoreChartDiv;

            initializeChart(overallRiverScoreChartDiv, [{ x: [], y: [], mode: 'lines', name: 'HST Score', line: { color: '#ec4899', width: 2 } }], 
                { ...anomalyLayout, title: { text: 'Overall HST Score', font: { size: 16, color: '#334155' } }, yaxis: {...anomalyLayout.yaxis, range: [0, 1]} });
            overallRiverScoreChartInstance = overallRiverScoreChartDiv;
            
            initializeChart(overallWarningLevelChartDiv, [{ x: [], y: [], mode: 'lines', name: 'Warning Level', line: { color: '#f97316', width: 2 } }], 
                { ...anomalyLayout, title: { text: 'Overall Warning Level', font: { size: 16, color: '#334155' } }, yaxis: {title: 'Level', ...anomalyLayout.yaxis, range: [0.0, 2.0]} });
            overallWarningLevelChartInstance = overallWarningLevelChartDiv;
        }

        /**
         * Initializes all charts for a specific individual node.
         */
        function initializeIndividualNodeChart(nodeId) {
            const nodeData = individualNodeData[nodeId];
            if (!nodeData) return;

            const sensorLayout = {
                title: { text: `Node ${nodeId} Sensor Data`, font: { size: 16, color: '#334155' } },
                yaxis: { title: 'Value', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0, 4095] }
            };
            const sensorChartDiv = document.getElementById(`nodeChart_${nodeId}`);
            if (sensorChartDiv) {
                initializeChart(sensorChartDiv, [
                    { x: nodeData.timestamps, y: nodeData.rain, mode: 'lines', name: 'Rain', line: { color: '#3b82f6', width: 2 } },
                    { x: nodeData.timestamps, y: nodeData.soil, mode: 'lines', name: 'Soil', line: { color: '#22c55e', width: 2 } },
                    { x: nodeData.timestamps, y: nodeData.vibration, mode: 'lines', name: 'Vib (g)', line: { color: '#ef4444', width: 2 } }
                ], sensorLayout);
                individualChartInstances[`sensor_${nodeId}`] = sensorChartDiv;
            }

            const anomalyLayout = { yaxis: { title: 'Score', showgrid: true, linecolor: '#cbd5e1', linewidth: 1 } };
            const isoChartDiv = document.getElementById(`nodeIsoScoreChart_${nodeId}`);
            if (isoChartDiv) {
                initializeChart(isoChartDiv, [{ x: nodeData.timestamps, y: nodeData.iso_score, mode: 'lines', name: 'IF Score', line: { color: '#8b5cf6', width: 2 } }], 
                    { ...anomalyLayout, title: { text: `Node ${nodeId} IF Score`, font: { size: 14, color: '#334155' } }, yaxis: {...anomalyLayout.yaxis, range: [-0.5, 0.5]} });
                individualChartInstances[`iso_${nodeId}`] = isoChartDiv;
            }

            const riverChartDiv = document.getElementById(`nodeRiverScoreChart_${nodeId}`);
            if (riverChartDiv) {
                initializeChart(riverChartDiv, [{ x: nodeData.timestamps, y: nodeData.river_score, mode: 'lines', name: 'HST Score', line: { color: '#ec4899', width: 2 } }], 
                    { ...anomalyLayout, title: { text: `Node ${nodeId} HST Score`, font: { size: 14, color: '#334155' } }, yaxis: {...anomalyLayout.yaxis, range: [0, 1]} });
                individualChartInstances[`river_${nodeId}`] = riverChartDiv;
            }

            const warningChartDiv = document.getElementById(`nodeWarningLevelChart_${nodeId}`);
            if (warningChartDiv) {
                initializeChart(warningChartDiv, [{ x: nodeData.timestamps, y: nodeData.warning_level_numerical, mode: 'lines', name: 'Warning Level', line: { color: '#f97316', width: 2 } }], 
                    { ...anomalyLayout, title: { text: `Node ${nodeId} Warning Level`, font: { size: 14, color: '#334155' } }, yaxis: {title: 'Level', ...anomalyLayout.yaxis, range: [0.0, 2.0]} });
                individualChartInstances[`warning_${nodeId}`] = warningChartDiv;
            }
        }

        /**
         * Updates all charts with new data.
         */
        function updateAllCharts() {
            const lastTimestamp = overallSensorData.timestamps.slice(-1);
            
            // Update Overall Charts
            Plotly.extendTraces(overallSensorChartInstance, { x: [lastTimestamp, lastTimestamp, lastTimestamp], y: [overallSensorData.rain.slice(-1), overallSensorData.soil.slice(-1), overallSensorData.vibration.slice(-1)] }, [0, 1, 2], MAX_DATA_POINTS);
            Plotly.extendTraces(overallIsoScoreChartInstance, { x: [lastTimestamp], y: [overallSensorData.iso_score.slice(-1)] }, [0], MAX_DATA_POINTS);
            Plotly.extendTraces(overallRiverScoreChartInstance, { x: [lastTimestamp], y: [overallSensorData.river_score.slice(-1)] }, [0], MAX_DATA_POINTS);
            Plotly.extendTraces(overallWarningLevelChartInstance, { x: [lastTimestamp], y: [overallSensorData.warning_level_numerical.slice(-1)] }, [0], MAX_DATA_POINTS);

            // Update Individual Node Charts
            for (const nodeId in individualNodeData) {
                const nodeData = individualNodeData[nodeId];
                const lastNodeTimestamp = nodeData.timestamps.slice(-1);
                
                Plotly.extendTraces(individualChartInstances[`sensor_${nodeId}`], { x: [lastNodeTimestamp, lastNodeTimestamp, lastNodeTimestamp], y: [nodeData.rain.slice(-1), nodeData.soil.slice(-1), nodeData.vibration.slice(-1)] }, [0, 1, 2], MAX_DATA_POINTS);
                Plotly.extendTraces(individualChartInstances[`iso_${nodeId}`], { x: [lastNodeTimestamp], y: [nodeData.iso_score.slice(-1)] }, [0], MAX_DATA_POINTS);
                Plotly.extendTraces(individualChartInstances[`river_${nodeId}`], { x: [lastNodeTimestamp], y: [nodeData.river_score.slice(-1)] }, [0], MAX_DATA_POINTS);
                Plotly.extendTraces(individualChartInstances[`warning_${nodeId}`], { x: [lastNodeTimestamp], y: [nodeData.warning_level_numerical.slice(-1)] }, [0], MAX_DATA_POINTS);
            }
        }

        /**
         * Updates the live metrics display for overall sensor data.
         */
        function updateOverallMetrics(latestData) {
            const format = (val, digits = 0) => (val !== undefined && val !== null ? val.toFixed(digits) : 'N/A');
            overallSensorMetricsDiv.innerHTML = `
                <div class="p-3 bg-blue-50 rounded-lg shadow-sm"><p class="text-sm text-blue-700 font-semibold">Rain</p><p class="text-xl font-bold text-blue-900">${format(latestData.rain)}</p></div>
                <div class="p-3 bg-green-50 rounded-lg shadow-sm"><p class="text-sm text-green-700 font-semibold">Soil Moisture</p><p class="text-xl font-bold text-green-900">${format(latestData.soil)}</p></div>
                <div class="p-3 bg-red-50 rounded-lg shadow-sm"><p class="text-sm text-red-700 font-semibold">Vibration (g)</p><p class="text-xl font-bold text-red-900">${format(latestData.vibration, 3)}g</p></div>`;

            overallAnomalyMetricsDiv.innerHTML = `
                <div class="p-3 bg-violet-50 rounded-lg shadow-sm"><p class="text-sm text-violet-700 font-semibold">IF Score</p><p class="text-xl font-bold text-violet-900">${format(latestData.iso_score, 3)}</p></div>
                <div class="p-3 bg-pink-50 rounded-lg shadow-sm"><p class="text-sm text-pink-700 font-semibold">HST Score</p><p class="text-xl font-bold text-pink-900">${format(latestData.river_score, 3)}</p></div>
                <div class="p-3 bg-orange-50 rounded-lg shadow-sm"><p class="text-sm text-orange-700 font-semibold">Warning Level</p><p class="text-xl font-bold text-orange-900">${format(latestData.warning_level_numerical, 3)}</p></div>`;
        }

        /**
         * Manages the creation and removal of individual node display sections.
         */
        function manageIndividualNodeDisplays(currentNodes) {
            const currentNodeIds = Object.keys(currentNodes);
            const knownNodeIds = Object.keys(individualNodeData);

            let gridClasses = 'grid gap-6';
            if (currentNodeIds.length === 1) gridClasses += ' grid-cols-1';
            else if (currentNodeIds.length === 2) gridClasses += ' grid-cols-1 sm:grid-cols-2';
            else gridClasses += ' grid-cols-1 sm:grid-cols-2 xl:grid-cols-3';

            if (currentNodeIds.length > 0) {
                individualNodesContainer.className = gridClasses;
                const noDataMessage = individualNodesContainer.querySelector('.text-gray-500');
                if (noDataMessage) noDataMessage.parentElement.remove();
            } else {
                individualNodesContainer.className = 'flex items-center justify-center h-64 w-full';
                individualNodesContainer.innerHTML = `<div class="p-4 bg-gray-50 rounded-lg text-center text-gray-500 border border-gray-200">No individual node data available yet.</div>`;
            }

            // Remove nodes that are no longer active
            knownNodeIds.forEach(nodeId => {
                if (!currentNodeIds.includes(nodeId)) {
                    document.getElementById(`nodeCard_${nodeId}`)?.remove();
                    ['sensor_', 'iso_', 'river_', 'warning_'].forEach(prefix => delete individualChartInstances[prefix + nodeId]);
                    delete individualNodeData[nodeId];
                }
            });

            // Add nodes that are new
            currentNodeIds.forEach(nodeId => {
                if (!knownNodeIds.includes(nodeId)) {
                    const nodeCard = document.createElement('div');
                    nodeCard.id = `nodeCard_${nodeId}`;
                    nodeCard.className = 'bg-[var(--card-bg)] p-4 rounded-lg shadow-md border border-gray-200';
                    nodeCard.innerHTML = `
                        <h3 class="text-xl font-bold text-gray-800 mb-3">Node ${nodeId}</h3>
                        <div id="nodeChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeIsoScoreChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeRiverScoreChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeWarningLevelChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeMetrics_${nodeId}" class="grid grid-cols-2 sm:grid-cols-3 gap-2 mt-4 text-center"></div>`;
                    individualNodesContainer.appendChild(nodeCard);
                    
                    individualNodeData[nodeId] = { timestamps: [], rain: [], soil: [], vibration: [], iso_score: [], river_score: [], warning_level_numerical: [] };
                    initializeIndividualNodeChart(nodeId);
                }
                updateIndividualNodeMetrics(nodeId, currentNodes[nodeId]);
            });

            Object.values(individualChartInstances).forEach(chart => Plotly.relayout(chart, { autosize: true }));
        }

        /**
         * Updates the live metrics display for an individual node.
         */
        function updateIndividualNodeMetrics(nodeId, latestData) {
            const nodeMetricsDiv = document.getElementById(`nodeMetrics_${nodeId}`);
            const format = (val, digits = 0) => (val !== undefined && val !== null ? val.toFixed(digits) : 'N/A');
            if (nodeMetricsDiv) {
                nodeMetricsDiv.innerHTML = `
                    <div class="p-2 bg-blue-50 rounded-md text-sm"><p class="text-blue-700 font-semibold">Rain:</p><p class="text-blue-900 font-bold">${format(latestData.rain)}</p></div>
                    <div class="p-2 bg-green-50 rounded-md text-sm"><p class="text-green-700 font-semibold">Soil:</p><p class="text-green-900 font-bold">${format(latestData.soil)}</p></div>
                    <div class="p-2 bg-red-50 rounded-md text-sm"><p class="text-red-700 font-semibold">Vib (g):</p><p class="text-red-900 font-bold">${format(latestData.vibration, 3)}g</p></div>
                    <div class="p-2 bg-orange-50 rounded-md text-sm"><p class="text-orange-700 font-semibold">Tilt:</p><p class="text-orange-900 font-bold">${format(latestData.tilt, 1)}Â°</p></div>
                    <div class="p-2 bg-violet-50 rounded-md text-sm"><p class="text-violet-700 font-semibold">IF Score:</p><p class="text-violet-900 font-bold">${format(latestData.iso_score, 3)}</p></div>
                    <div class="p-2 bg-pink-50 rounded-md text-sm"><p class="text-pink-700 font-semibold">HST Score:</p><p class="text-pink-900 font-bold">${format(latestData.river_score, 3)}</p></div>
                    <div class="p-2 bg-orange-50 rounded-md text-sm"><p class="text-orange-700 font-semibold">Warning:</p><p class="text-orange-900 font-bold">${format(latestData.warning_level_numerical, 3)}</p></div>`;
            }
        }

        /**
         * Updates the list of active nodes displayed on the dashboard.
         */
        function updateActiveNodesList(nodeIds) {
            activeNodesListDiv.innerHTML = nodeIds.length === 0 ? '<p class="text-gray-500">No nodes detected yet...</p>' : 
                nodeIds.map(id => `<div class="flex items-center text-gray-700 py-1"><span class="h-2 w-2 rounded-full bg-blue-400 mr-2"></span><span>Node ${id}</span></div>`).join('');
        }

        /**
         * Updates the current data table with the latest information for each node.
         */
        function updateNodeDataTable(nodesData) {
            const nodeIds = Object.keys(nodesData).sort();
            if (nodeIds.length === 0) {
                nodeDataTableBody.innerHTML = '<tr><td colspan="10" class="text-center text-gray-500 py-4">No node data available.</td></tr>';
                return;
            }
            let tableHtml = '';
            nodeIds.forEach(nodeId => {
                const node = nodesData[nodeId];
                const format = (val, digits = 0) => (val !== undefined && val !== null ? val.toFixed(digits) : 'N/A');
                // **FIX:** Use the generated timestamp for the table as well
                const timestamp = new Date().toLocaleTimeString();
                tableHtml += `
                    <tr>
                        <td>${nodeId}</td>
                        <td>${timestamp}</td>
                        <td>${node.mac || 'N/A'}</td>
                        <td>${format(node.rain)}</td>
                        <td>${format(node.soil)}</td>
                        <td>${format(node.vibration, 3)}</td>
                        <td>${format(node.tilt, 1)}</td>
                        <td>${format(node.iso_score, 3)}</td>
                        <td>${format(node.river_score, 3)}</td>
                        <td>${format(node.warning_level_numerical, 3)}</td>
                    </tr>`;
            });
            nodeDataTableBody.innerHTML = tableHtml;
        }

        /**
         * Sets the connection status display.
         */
        function setConnectionStatus(isConnected, message) {
            connectionMessage.textContent = message;
            if (isConnected) {
                connectionStatusDot.className = 'relative inline-flex rounded-full h-3 w-3 bg-green-500';
                connectionStatusPulse.className = 'animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75';
                connectionMessage.className = 'text-lg font-medium text-green-700';
            } else {
                connectionStatusDot.className = 'relative inline-flex rounded-full h-3 w-3 bg-red-500';
                connectionStatusPulse.className = 'absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75';
                connectionMessage.className = 'text-lg font-medium text-red-700';
            }
        }
        
        // --- Main Data Fetching and Processing Logic ---
        async function fetchSensorData() {
            try {
                const response = await fetch(API_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                // Exit if no data is available from the server
                if (!data || !data.overall_data || !data.nodes) {
                    setConnectionStatus(false, 'Waiting for data...');
                    return;
                }

                setConnectionStatus(true, 'Connected to Backend');
                lastUpdateTimeSpan.textContent = new Date().toLocaleTimeString();
                updateCsvLoggingStatus(data.is_logging_active);

                // **FIX:** Generate a single, reliable timestamp for this entire data packet
                const timestamp = new Date();

                // --- Process Data ---
                // Add new data point to overall data history
                Object.keys(overallSensorData).forEach(key => {
                    const value = key === 'timestamps' ? timestamp : data.overall_data[key.replace('_numerical', '')];
                    overallSensorData[key].push(value);
                    if (overallSensorData[key].length > MAX_DATA_POINTS) {
                        overallSensorData[key].shift();
                    }
                });

                // Manage the display cards for individual nodes
                manageIndividualNodeDisplays(data.nodes);

                // Add new data points to individual node histories
                for (const nodeId in data.nodes) {
                    const nodeData = data.nodes[nodeId];
                    const nodeHistory = individualNodeData[nodeId];
                    if (nodeHistory) {
                        Object.keys(nodeHistory).forEach(key => {
                            const value = key === 'timestamps' ? timestamp : nodeData[key.replace('_numerical', '')];
                            nodeHistory[key].push(value);
                            if (nodeHistory[key].length > MAX_DATA_POINTS) {
                                nodeHistory[key].shift();
                            }
                        });
                    }
                }

                // --- Update UI ---
                updateAllCharts();
                updateOverallMetrics(data.overall_data);
                updateNodeDataTable(data.nodes);
                updateActiveNodesList(Object.keys(data.nodes));

            } catch (error) {
                console.error('Error fetching sensor data:', error);
                setConnectionStatus(false, 'Disconnected from Backend');
            }
        }

        // --- Event Listeners and Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeAllCharts();
            fetchSensorData();
            setInterval(fetchSensorData, FETCH_INTERVAL_MS);

            // Theme toggle
            const themeIcon = document.getElementById("themeIcon");
            themeIcon.addEventListener("click", () => {
                document.body.classList.toggle("dark-mode");
                themeIcon.textContent = document.body.classList.contains("dark-mode") ? "â˜€ï¸" : "ðŸŒ™";
            });
            themeIcon.textContent = document.body.classList.contains("dark-mode") ? "â˜€ï¸" : "ðŸŒ™";

            // Other event listeners...
            // (Add listeners for mode control and CSV buttons here)
        });

        window.onresize = () => {
            Object.values(individualChartInstances).forEach(chart => Plotly.relayout(chart, { autosize: true }));
            if (overallSensorChartInstance) Plotly.relayout(overallSensorChartInstance, { autosize: true });
            if (overallIsoScoreChartInstance) Plotly.relayout(overallIsoScoreChartInstance, { autosize: true });
            if (overallRiverScoreChartInstance) Plotly.relayout(overallRiverScoreChartInstance, { autosize: true });
            if (overallWarningLevelChartInstance) Plotly.relayout(overallWarningLevelChartInstance, { autosize: true });
        };
    </script>
</body>
</html>
