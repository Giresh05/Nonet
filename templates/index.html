<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NoNet Cloud Dashboard</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Plotly.js from a CDN (Updated to a newer version) -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        /* Custom CSS for font and scrollbar */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        :root {
            --bg-color: #f0f2f5; /* Light gray background */
            --text-color: #333;
            --card-bg: #fff;
            --nav-bg: #1e3a8a; /* Dark blue for nav */
            --nav-text: white;
            --nav-hover-bg: #2563eb; /* Blue-600 */
            --nav-active-text: #fcd34d; /* Amber-300 */
        }
        body.dark-mode {
            --bg-color: #1c1e21;
            --text-color: #f0f0f0;
            --card-bg: #2a2d31;
            --nav-bg: #1a202c; /* Darker for dark mode nav */
            --nav-text: #cbd5e1;
            --nav-hover-bg: #2d3748;
            --nav-active-text: #fcd34d;
        }

        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e2e8f0; /* Tailwind gray-200 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* Tailwind gray-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* Tailwind gray-500 */
        }
        /* Table styling */
        .node-table th, .node-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0; /* Tailwind gray-200 */
        }
        .node-table th {
            background-color: #f1f5f9; /* Tailwind slate-100 */
            font-weight: 600;
            color: #475569; /* Tailwind slate-600 */
            font-size: 0.875rem; /* sm text */
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .node-table tbody tr:hover {
            background-color: #f8fafc; /* Tailwind gray-50 */
        }
        .node-table tbody tr:last-child td {
            border-bottom: none;
        }
        /* Theme toggle button styling */
        #themeIcon {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--nav-text); /* Matches nav text color */
            transition: color 0.3s ease;
            z-index: 10; /* Ensure it's above other elements */
        }
    </style>
</head>
<body class="bg-[var(--bg-color)] text-[var(--text-color)] min-h-screen flex flex-col items-center">
    <button id="themeIcon">ðŸŒ™</button>

    <!-- Navigation Bar -->
    <nav class="bg-[var(--nav-bg)] p-4 shadow-md flex justify-center relative w-full">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <div class="text-2xl font-bold text-[var(--nav-text)] mb-2 sm:mb-0">NoNet Cloud</div>
            <div class="flex space-x-4">
                <a href="/" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">Home</a>
                <a href="/dashboard" class="text-[var(--nav-active-text)] font-semibold hover:text-[var(--nav-text)] py-2 px-3 rounded-md transition duration-300 bg-[var(--nav-hover-bg)]">Dashboard</a>
                <a href="/map" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">Map</a>
                <a href="/about" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">About</a>
            </div>
        </div>
    </nav>

    <!-- Header Section -->
    <header class="w-full max-w-6xl text-center mb-8 p-4 sm:p-6">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-700 mb-2 drop-shadow-lg">
            NoNet Cloud Sensor Dashboard
        </h1>
        <p class="text-lg text-gray-600">Live monitoring of remotely forwarded sensor data</p>
    </header>

    <!-- Main Content Area -->
    <main class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-3 gap-6 p-4 sm:p-6">

        <!-- Overall Sensor Data Section (Left/Top) -->
        <section class="lg:col-span-2 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Overall Sensor Data (Average)</h2>
            <div id="overallSensorChart" class="w-full h-80 sm:h-96 bg-gray-50 rounded-lg border border-gray-200">
                <!-- Plotly chart will be rendered here -->
            </div>
            <div id="overallSensorMetrics" class="grid grid-cols-2 sm:grid-cols-3 gap-4 mt-6 text-center">
                <!-- Live metrics will be updated here by JavaScript -->
            </div>
        </section>

        <!-- Status & Last Update Section (Right/Top) -->
        <section class="lg:col-span-1 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200 flex flex-col justify-between">
            <div>
                <h2 class="text-2xl font-bold text-gray-800 mb-4">System Status</h2>
                <div class="flex items-center mb-4">
                    <span class="relative flex h-3 w-3 mr-3">
                        <span id="connectionStatusPulse" class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                        <span id="connectionStatusDot" class="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
                    </span>
                    <p id="connectionMessage" class="text-lg font-medium text-green-700">Receiving Data</p>
                </div>
                <p class="text-md text-gray-600 mb-2">Last data received from local server:</p>
                <p id="lastUpdateTime" class="text-lg font-semibold text-blue-600">N/A</p>
            </div>
            <div class="mt-6 pt-4 border-t border-gray-200">
                <h3 class="text-xl font-bold text-gray-800 mb-3">Active Nodes</h3>
                <div id="activeNodesList" class="max-h-40 overflow-y-auto pr-2">
                    <!-- Active nodes will be listed here by JavaScript -->
                    <p class="text-gray-500">No nodes detected yet...</p>
                </div>
            </div>
        </section>

        <!-- Overall Anomaly Data Section -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Overall Anomaly Scores (Average)</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div id="overallIsoScoreChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div id="overallRiverScoreChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div id="overallWarningLevelChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
            </div>
            <div id="overallAnomalyMetrics" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mt-6 text-center">
                <!-- Live anomaly metrics will be updated here by JavaScript -->
            </div>
        </section>

        <!-- Current Node Data Table -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Current Node Data Table</h2>
            <div class="overflow-x-auto">
                <table id="nodeDataTable" class="min-w-full bg-white rounded-lg node-table">
                    <thead>
                        <tr>
                            <th>Node ID</th>
                            <th>Last Seen (Local Time)</th>
                            <th>MAC Address</th>
                            <th>Rain</th>
                            <th>Soil</th>
                            <th>Vibration (g)</th>
                            <th>Tilt (Â°)</th>
                            <th>IF Score</th>
                            <th>HST Score</th>
                            <th>Warning Level</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be dynamically populated here -->
                        <tr><td colspan="10" class="text-center text-gray-500 py-4">No node data available.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Individual Node Data Section (Bottom) -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Individual Node Data & Anomaly Scores</h2>
            <div id="individualNodesContainer" class="">
                <!-- Individual node charts will be dynamically added here by JavaScript -->
                <div class="p-4 bg-gray-50 rounded-lg text-center text-gray-500 border border-gray-200">
                    No individual node data available yet.
                </div>
            </div>
        </section>

    </main>

    <!-- JavaScript for fetching data and updating charts -->
    <script>
        // Configuration for the data fetching
        const API_URL = '/api/live_data'; // Endpoint for the Render server backend
        const FETCH_INTERVAL_MS = 2000; // Fetch new data every 2 seconds
        const MAX_DATA_POINTS = 60; // Keep last 60 data points for charts

        // Data storage for overall sensor data
        let overallSensorData = {
            timestamps: [],
            rain: [],
            soil: [],
            vibration: [],
            iso_score: [],
            river_score: [],
            warning_level_numerical: []
        };

        // Object to store data for individual nodes, keyed by node ID
        let individualNodeData = {};
        
        // Keep track of the last update timestamp to avoid re-rendering identical data
        let lastKnownUpdateTimestamp = null;

        // DOM elements
        const overallSensorChartDiv = document.getElementById('overallSensorChart');
        const overallSensorMetricsDiv = document.getElementById('overallSensorMetrics');
        const overallIsoScoreChartDiv = document.getElementById('overallIsoScoreChart');
        const overallRiverScoreChartDiv = document.getElementById('overallRiverScoreChart');
        const overallWarningLevelChartDiv = document.getElementById('overallWarningLevelChart');
        const overallAnomalyMetricsDiv = document.getElementById('overallAnomalyMetrics');
        const individualNodesContainer = document.getElementById('individualNodesContainer');
        const lastUpdateTimeSpan = document.getElementById('lastUpdateTime');
        const connectionStatusDot = document.getElementById('connectionStatusDot');
        const connectionStatusPulse = document.getElementById('connectionStatusPulse');
        const connectionMessage = document.getElementById('connectionMessage');
        const activeNodesListDiv = document.getElementById('activeNodesList');
        const nodeDataTableBody = document.querySelector('#nodeDataTable tbody');

        // Plotly chart instances
        let overallSensorChartInstance;
        let overallIsoScoreChartInstance;
        let overallRiverScoreChartInstance;
        let overallWarningLevelChartInstance;
        const individualChartInstances = {};

        /**
         * Initializes the overall sensor data chart using Plotly.js.
         */
        function initializeOverallSensorChart() {
            const layout = {
                title: { text: 'Overall Sensor Trends', font: { size: 18, color: '#334155' }, y: 0.99 },
                xaxis: { 
                    title: 'Time', 
                    showgrid: true, 
                    linecolor: '#cbd5e1', 
                    linewidth: 1 
                },
                yaxis: { title: 'Value', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0, 4095] },
                margin: { l: 50, r: 20, t: 50, b: 50 },
                hovermode: 'x unified',
                responsive: true,
                paper_bgcolor: 'var(--card-bg)',
                plot_bgcolor: 'var(--card-bg)',
                font: { family: 'Inter, sans-serif', color: 'var(--text-color)' },
                legend: { x: 0, y: 1.15, orientation: 'h', bgcolor: 'rgba(255, 255, 255, 0)', bordercolor: 'rgba(255, 255, 255, 0)' }
            };

            const data = [
                { x: [], y: [], mode: 'lines', name: 'Rain', line: { color: '#3b82f6', width: 2 } },
                { x: [], y: [], mode: 'lines', name: 'Soil Moisture', line: { color: '#22c55e', width: 2 } },
                { x: [], y: [], mode: 'lines', name: 'Vibration (g)', line: { color: '#ef4444', width: 2 } }
            ];

            Plotly.newPlot(overallSensorChartDiv, data, layout, { displayModeBar: false, responsive: true });
            overallSensorChartInstance = overallSensorChartDiv;
        }

        /**
         * Initializes the overall anomaly score charts using Plotly.js.
         */
        function initializeOverallAnomalyCharts() {
            const commonLayout = {
                xaxis: { 
                    title: 'Time', 
                    showgrid: true, 
                    linecolor: '#cbd5e1', 
                    linewidth: 1 
                },
                margin: { l: 50, r: 20, t: 40, b: 50 },
                hovermode: 'x unified',
                responsive: true,
                paper_bgcolor: 'var(--card-bg)',
                plot_bgcolor: 'var(--card-bg)',
                font: { family: 'Inter, sans-serif', color: 'var(--text-color)' },
                legend: { x: 0, y: 1.15, orientation: 'h', bgcolor: 'rgba(255, 255, 255, 0)', bordercolor: 'rgba(255, 255, 255, 0)' }
            };

            const isoLayout = { ...commonLayout, title: { text: 'Overall Isolation Forest Score', font: { size: 16, color: '#334155' } }, yaxis: { title: 'Score', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [-0.5, 0.5] } };
            Plotly.newPlot(overallIsoScoreChartDiv, [{ x: [], y: [], mode: 'lines', name: 'IF Score', line: { color: '#8b5cf6', width: 2 } }], isoLayout, { displayModeBar: false, responsive: true });
            overallIsoScoreChartInstance = overallIsoScoreChartDiv;

            const riverLayout = { ...commonLayout, title: { text: 'Overall HalfSpaceTrees Score', font: { size: 16, color: '#334155' } }, yaxis: { title: 'Score', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0, 1] } };
            Plotly.newPlot(overallRiverScoreChartDiv, [{ x: [], y: [], mode: 'lines', name: 'HST Score', line: { color: '#ec4899', width: 2 } }], riverLayout, { displayModeBar: false, responsive: true });
            overallRiverScoreChartInstance = overallRiverScoreChartDiv;

            const warningLayout = { ...commonLayout, title: { text: 'Overall Ensemble Warning Level', font: { size: 16, color: '#334155' } }, yaxis: { title: 'Level', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0.0, 2.0] } };
            Plotly.newPlot(overallWarningLevelChartDiv, [{ x: [], y: [], mode: 'lines', name: 'Warning Level', line: { color: '#f97316', width: 2 } }], warningLayout, { displayModeBar: false, responsive: true });
            overallWarningLevelChartInstance = overallWarningLevelChartDiv;
        }

        /**
         * Updates the overall charts with new data.
         */
        function updateOverallCharts(timestamp, data) {
            if (!overallSensorChartInstance) initializeOverallSensorChart();
            if (!overallIsoScoreChartInstance) initializeOverallAnomalyCharts();

            const update = (chart, y_data, trace_index) => {
                Plotly.extendTraces(chart, { x: [[timestamp]], y: [[y_data]] }, [trace_index], MAX_DATA_POINTS);
            };

            update(overallSensorChartInstance, data.rain, 0);
            update(overallSensorChartInstance, data.soil, 1);
            update(overallSensorChartInstance, data.vibration, 2);
            update(overallIsoScoreChartInstance, data.iso_score, 0);
            update(overallRiverScoreChartInstance, data.river_score, 0);
            update(overallWarningLevelChartInstance, data.warning_level_numerical, 0);
        }

        /**
         * Updates the live metrics display for overall sensor data.
         */
        function updateOverallMetrics(latestData) {
            const format = (val, digits = 0) => (val !== undefined && val !== null ? val.toFixed(digits) : 'N/A');
            overallSensorMetricsDiv.innerHTML = `
                <div class="p-3 bg-blue-50 rounded-lg shadow-sm"><p class="text-sm text-blue-700 font-semibold">Rain</p><p class="text-xl font-bold text-blue-900">${format(latestData.rain)}</p></div>
                <div class="p-3 bg-green-50 rounded-lg shadow-sm"><p class="text-sm text-green-700 font-semibold">Soil Moisture</p><p class="text-xl font-bold text-green-900">${format(latestData.soil)}</p></div>
                <div class="p-3 bg-red-50 rounded-lg shadow-sm"><p class="text-sm text-red-700 font-semibold">Vibration (g)</p><p class="text-xl font-bold text-red-900">${format(latestData.vibration, 3)}g</p></div>`;

            overallAnomalyMetricsDiv.innerHTML = `
                <div class="p-3 bg-violet-50 rounded-lg shadow-sm"><p class="text-sm text-violet-700 font-semibold">IF Score</p><p class="text-xl font-bold text-violet-900">${format(latestData.iso_score, 3)}</p></div>
                <div class="p-3 bg-pink-50 rounded-lg shadow-sm"><p class="text-sm text-pink-700 font-semibold">HST Score</p><p class="text-xl font-bold text-pink-900">${format(latestData.river_score, 3)}</p></div>
                <div class="p-3 bg-orange-50 rounded-lg shadow-sm"><p class="text-sm text-orange-700 font-semibold">Warning Level</p><p class="text-xl font-bold text-orange-900">${format(latestData.warning_level_numerical, 3)}</p></div>`;
        }

        /**
         * Initializes all charts for a specific individual node.
         */
        function initializeIndividualNodeChart(nodeId) {
            const chartDivId = `nodeChart_${nodeId}`;
            const isoChartDivId = `nodeIsoScoreChart_${nodeId}`;
            const riverChartDivId = `nodeRiverScoreChart_${nodeId}`;
            const warningChartDivId = `nodeWarningLevelChart_${nodeId}`;

            const chartDiv = document.getElementById(chartDivId);
            const isoChartDiv = document.getElementById(isoChartDivId);
            const riverChartDiv = document.getElementById(riverChartDivId);
            const warningChartDiv = document.getElementById(warningChartDivId);

            if (!chartDiv || !isoChartDiv || !riverChartDiv || !warningChartDiv) return;

            const commonLayout = {
                xaxis: { 
                    title: 'Time', 
                    showgrid: true, 
                    linecolor: '#cbd5e1', 
                    linewidth: 1 
                },
                margin: { l: 50, r: 20, t: 40, b: 50 },
                hovermode: 'x unified',
                responsive: true,
                paper_bgcolor: 'var(--card-bg)',
                plot_bgcolor: 'var(--card-bg)',
                font: { family: 'Inter, sans-serif', color: 'var(--text-color)' },
                legend: { x: 0, y: 1.15, orientation: 'h', bgcolor: 'rgba(255, 255, 255, 0)', bordercolor: 'rgba(255, 255, 255, 0)' }
            };

            const sensorLayout = { ...commonLayout, title: { text: `Node ${nodeId} Sensor Data`, font: { size: 16, color: '#334155' } }, yaxis: { title: 'Value', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0, 4095] } };
            Plotly.newPlot(chartDiv, [
                { x: [], y: [], mode: 'lines', name: 'Rain', line: { color: '#3b82f6', width: 2 } },
                { x: [], y: [], mode: 'lines', name: 'Soil', line: { color: '#22c55e', width: 2 } },
                { x: [], y: [], mode: 'lines', name: 'Vib (g)', line: { color: '#ef4444', width: 2 } }
            ], sensorLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`sensor_${nodeId}`] = chartDiv;

            const isoLayout = { ...commonLayout, title: { text: `Node ${nodeId} IF Score`, font: { size: 14, color: '#334155' } }, yaxis: { title: 'Score', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [-0.5, 0.5] } };
            Plotly.newPlot(isoChartDiv, [{ x: [], y: [], mode: 'lines', name: 'IF Score', line: { color: '#8b5cf6', width: 2 } }], isoLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`iso_${nodeId}`] = isoChartDiv;

            const riverLayout = { ...commonLayout, title: { text: `Node ${nodeId} HST Score`, font: { size: 14, color: '#334155' } }, yaxis: { title: 'Score', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0, 1] } };
            Plotly.newPlot(riverChartDiv, [{ x: [], y: [], mode: 'lines', name: 'HST Score', line: { color: '#ec4899', width: 2 } }], riverLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`river_${nodeId}`] = riverChartDiv;

            const warningLayout = { ...commonLayout, title: { text: `Node ${nodeId} Warning Level`, font: { size: 14, color: '#334155' } }, yaxis: { title: 'Level', showgrid: true, linecolor: '#cbd5e1', linewidth: 1, range: [0.0, 2.0] } };
            Plotly.newPlot(warningChartDiv, [{ x: [], y: [], mode: 'lines', name: 'Warning Level', line: { color: '#f97316', width: 2 } }], warningLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`warning_${nodeId}`] = warningChartDiv;
        }

        /**
         * Updates the charts for a specific individual node with new data.
         */
        function updateIndividualNodeChart(nodeId) {
            const nodeData = individualNodeData[nodeId];
            if (!nodeData || !individualChartInstances[`sensor_${nodeId}`]) return;
            
            const lastTimestamp = nodeData.timestamps[nodeData.timestamps.length - 1];

            const update = (chartKey, y_data_key, trace_index) => {
                const chart = individualChartInstances[chartKey];
                const y_data = nodeData[y_data_key][nodeData[y_data_key].length - 1];
                if (chart) {
                    Plotly.extendTraces(chart, { x: [[lastTimestamp]], y: [[y_data]] }, [trace_index], MAX_DATA_POINTS);
                }
            };
            
            update(`sensor_${nodeId}`, 'rain', 0);
            update(`sensor_${nodeId}`, 'soil', 1);
            update(`sensor_${nodeId}`, 'vibration', 2);
            update(`iso_${nodeId}`, 'iso_score', 0);
            update(`river_${nodeId}`, 'river_score', 0);
            update(`warning_${nodeId}`, 'warning_level_numerical', 0);
        }

        /**
         * Manages the creation and removal of individual node display sections.
         */
        function manageIndividualNodeDisplays(currentNodes) {
            const currentNodeIds = Object.keys(currentNodes);
            const displayedNodeIds = new Set(Object.keys(individualChartInstances).map(k => k.split('_')[1]));

            let gridClasses = 'grid gap-6';
            if (currentNodeIds.length === 1) gridClasses += ' grid-cols-1';
            else if (currentNodeIds.length === 2) gridClasses += ' grid-cols-1 sm:grid-cols-2';
            else gridClasses += ' grid-cols-1 sm:grid-cols-2 xl:grid-cols-3';

            if (currentNodeIds.length > 0) {
                individualNodesContainer.className = gridClasses;
                const noDataMessage = individualNodesContainer.querySelector('.text-gray-500');
                if (noDataMessage) noDataMessage.parentElement.remove();
            } else {
                individualNodesContainer.className = 'flex items-center justify-center h-64 w-full';
                individualNodesContainer.innerHTML = `<div class="p-4 bg-gray-50 rounded-lg text-center text-gray-500 border border-gray-200">No individual node data available yet.</div>`;
            }

            // Remove nodes that are no longer active
            displayedNodeIds.forEach(nodeId => {
                if (!currentNodeIds.includes(nodeId)) {
                    document.getElementById(`nodeCard_${nodeId}`)?.remove();
                    ['sensor_', 'iso_', 'river_', 'warning_'].forEach(prefix => delete individualChartInstances[prefix + nodeId]);
                    delete individualNodeData[nodeId];
                }
            });

            // Add or update nodes that are active
            currentNodeIds.forEach(nodeId => {
                if (!individualChartInstances[`sensor_${nodeId}`]) {
                    const nodeCard = document.createElement('div');
                    nodeCard.id = `nodeCard_${nodeId}`;
                    nodeCard.className = 'bg-[var(--card-bg)] p-4 rounded-lg shadow-md border border-gray-200';
                    nodeCard.innerHTML = `
                        <h3 class="text-xl font-bold text-gray-800 mb-3">Node ${nodeId}</h3>
                        <div id="nodeChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeIsoScoreChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeRiverScoreChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeWarningLevelChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeMetrics_${nodeId}" class="grid grid-cols-2 sm:grid-cols-3 gap-2 mt-4 text-center"></div>`;
                    individualNodesContainer.appendChild(nodeCard);
                    initializeIndividualNodeChart(nodeId);
                }
                updateIndividualNodeMetrics(nodeId, currentNodes[nodeId]);
            });

            // Relayout all active charts after DOM changes
            Object.values(individualChartInstances).forEach(chart => Plotly.relayout(chart, { autosize: true }));
        }

        /**
         * Updates the live metrics display for an individual node.
         */
        function updateIndividualNodeMetrics(nodeId, latestData) {
            const nodeMetricsDiv = document.getElementById(`nodeMetrics_${nodeId}`);
            const format = (val, digits = 0) => (val !== undefined && val !== null ? val.toFixed(digits) : 'N/A');
            if (nodeMetricsDiv) {
                nodeMetricsDiv.innerHTML = `
                    <div class="p-2 bg-blue-50 rounded-md text-sm"><p class="text-blue-700 font-semibold">Rain:</p><p class="text-blue-900 font-bold">${format(latestData.rain)}</p></div>
                    <div class="p-2 bg-green-50 rounded-md text-sm"><p class="text-green-700 font-semibold">Soil:</p><p class="text-green-900 font-bold">${format(latestData.soil)}</p></div>
                    <div class="p-2 bg-red-50 rounded-md text-sm"><p class="text-red-700 font-semibold">Vib (g):</p><p class="text-red-900 font-bold">${format(latestData.vibration, 3)}g</p></div>
                    <div class="p-2 bg-orange-50 rounded-md text-sm"><p class="text-orange-700 font-semibold">Tilt:</p><p class="text-orange-900 font-bold">${format(latestData.tilt, 1)}Â°</p></div>
                    <div class="p-2 bg-violet-50 rounded-md text-sm"><p class="text-violet-700 font-semibold">IF Score:</p><p class="text-violet-900 font-bold">${format(latestData.iso_score, 3)}</p></div>
                    <div class="p-2 bg-pink-50 rounded-md text-sm"><p class="text-pink-700 font-semibold">HST Score:</p><p class="text-pink-900 font-bold">${format(latestData.river_score, 3)}</p></div>
                    <div class="p-2 bg-orange-50 rounded-md text-sm"><p class="text-orange-700 font-semibold">Warning:</p><p class="text-orange-900 font-bold">${format(latestData.warning_level_numerical, 3)}</p></div>`;
            }
        }

        /**
         * Updates the list of active nodes displayed on the dashboard.
         */
        function updateActiveNodesList(nodeIds) {
            if (nodeIds.length === 0) {
                activeNodesListDiv.innerHTML = '<p class="text-gray-500">No nodes detected yet...</p>';
            } else {
                activeNodesListDiv.innerHTML = nodeIds.map(id => `<div class="flex items-center text-gray-700 py-1"><span class="h-2 w-2 rounded-full bg-blue-400 mr-2"></span><span>Node ${id}</span></div>`).join('');
            }
        }

        /**
         * Updates the current data table with the latest information for each node.
         */
        function updateNodeDataTable(nodesData) {
            let tableHtml = '';
            const nodeIds = Object.keys(nodesData).sort();

            if (nodeIds.length === 0) {
                tableHtml = '<tr><td colspan="10" class="text-center text-gray-500 py-4">No node data available.</td></tr>';
            } else {
                nodeIds.forEach(nodeId => {
                    const node = nodesData[nodeId];
                    const timestamp = node.last_seen_by_flask ? new Date(node.last_seen_by_flask).toLocaleTimeString() : 'N/A';
                    const format = (val, digits = 0) => (val !== undefined && val !== null ? val.toFixed(digits) : 'N/A');
                    tableHtml += `
                        <tr>
                            <td>${nodeId}</td>
                            <td>${timestamp}</td>
                            <td>${node.mac || 'N/A'}</td>
                            <td>${format(node.rain)}</td>
                            <td>${format(node.soil)}</td>
                            <td>${format(node.vibration, 3)}</td>
                            <td>${format(node.tilt, 1)}</td>
                            <td>${format(node.iso_score, 3)}</td>
                            <td>${format(node.river_score, 3)}</td>
                            <td>${format(node.warning_level_numerical, 3)}</td>
                        </tr>`;
                });
            }
            nodeDataTableBody.innerHTML = tableHtml;
        }

        /**
         * Sets the connection status display.
         */
        function setConnectionStatus(isReceiving, message, lastUpdate) {
            if (isReceiving) {
                connectionStatusDot.classList.remove('bg-red-500');
                connectionStatusDot.classList.add('bg-green-500');
                connectionStatusPulse.classList.add('animate-ping');
                connectionMessage.classList.remove('text-red-700');
                connectionMessage.classList.add('text-green-700');
                lastUpdateTimeSpan.textContent = lastUpdate ? new Date(lastUpdate).toLocaleString() : 'N/A';
            } else {
                connectionStatusDot.classList.remove('bg-green-500');
                connectionStatusDot.classList.add('bg-red-500');
                connectionStatusPulse.classList.remove('animate-ping');
                connectionMessage.classList.remove('text-green-700');
                connectionMessage.classList.add('text-red-700');
            }
            connectionMessage.textContent = message;
        }

        /**
         * Fetches live sensor data from the Render server backend API.
         */
        async function fetchSensorData() {
            try {
                const response = await fetch(API_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                if (!data.last_updated) {
                    setConnectionStatus(false, 'Waiting for data...', null);
                    return;
                }
                
                if (data.last_updated === lastKnownUpdateTimestamp) {
                    setConnectionStatus(true, 'Receiving Data', data.last_updated);
                    return; 
                }
                
                lastKnownUpdateTimestamp = data.last_updated;
                setConnectionStatus(true, 'Receiving Data', data.last_updated);

                // Process and update all UI components with the new data
                const overallData = data.overall_data;
                const nodesData = data.nodes;
                const overallTimestamp = new Date(overallData.timestamp);

                updateOverallCharts(overallTimestamp, overallData);
                updateOverallMetrics(overallData);
                manageIndividualNodeDisplays(nodesData);
                updateNodeDataTable(nodesData);
                updateActiveNodesList(Object.keys(nodesData));

                // Process and store historical data for individual nodes
                for (const nodeId in nodesData) {
                    const nodeData = nodesData[nodeId];
                    const nodeTimestamp = new Date(nodeData.last_seen_by_flask);

                    // Ensure the data structure exists for the node
                    if (!individualNodeData[nodeId]) {
                        individualNodeData[nodeId] = {
                            timestamps: [], rain: [], soil: [], vibration: [],
                            iso_score: [], river_score: [], warning_level_numerical: []
                        };
                    }

                    // Add new data point to the historical arrays
                    const nodeHistory = individualNodeData[nodeId];
                    nodeHistory.timestamps.push(nodeTimestamp);
                    nodeHistory.rain.push(nodeData.rain);
                    nodeHistory.soil.push(nodeData.soil);
                    nodeHistory.vibration.push(nodeData.vibration);
                    nodeHistory.iso_score.push(nodeData.iso_score);
                    nodeHistory.river_score.push(nodeData.river_score);
                    nodeHistory.warning_level_numerical.push(nodeData.warning_level_numerical);

                    // Trim old data to maintain MAX_DATA_POINTS
                    if (nodeHistory.timestamps.length > MAX_DATA_POINTS) {
                        Object.keys(nodeHistory).forEach(key => nodeHistory[key].shift());
                    }
                    
                    // Update the chart for this specific node
                    updateIndividualNodeChart(nodeId);
                }

            } catch (error) {
                console.error('Error fetching sensor data:', error);
                setConnectionStatus(false, 'Error connecting to server', null);
            }
        }

        // Initialize charts and start fetching data when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeOverallSensorChart();
            initializeOverallAnomalyCharts();
            fetchSensorData(); // Initial fetch
            setInterval(fetchSensorData, FETCH_INTERVAL_MS);

            const themeIcon = document.getElementById("themeIcon");
            if (document.body.classList.contains("dark-mode")) themeIcon.textContent = "â˜€ï¸";
            else themeIcon.textContent = "ðŸŒ™";

            themeIcon.addEventListener("click", function () {
                document.body.classList.toggle("dark-mode");
                themeIcon.textContent = document.body.classList.contains("dark-mode") ? "â˜€ï¸" : "ðŸŒ™";
            });

            window.onresize = function() {
                Object.values(individualChartInstances).forEach(chart => Plotly.relayout(chart, { autosize: true }));
                if (overallSensorChartInstance) Plotly.relayout(overallSensorChartInstance, { autosize: true });
                if (overallIsoScoreChartInstance) Plotly.relayout(overallIsoScoreChartInstance, { autosize: true });
                if (overallRiverScoreChartInstance) Plotly.relayout(overallRiverScoreChartInstance, { autosize: true });
                if (overallWarningLevelChartInstance) Plotly.relayout(overallWarningLevelChartInstance, { autosize: true });
            };
        });
    </script>
</body>
</html>
