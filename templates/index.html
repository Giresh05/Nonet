<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Sensor & Anomaly Dashboard</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Custom CSS for font and scrollbar */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        :root {
            --bg-color: #f0f2f5; /* Light gray background */
            --text-color: #333;
            --card-bg: #fff;
            --nav-bg: #1e3a8a; /* Dark blue for nav */
            --nav-text: white;
            --nav-hover-bg: #2563eb; /* Blue-600 */
            --nav-active-text: #fcd34d; /* Amber-300 */
        }
        body.dark-mode {
            --bg-color: #1c1e21;
            --text-color: #f0f0f0;
            --card-bg: #2a2d31;
            --nav-bg: #1a202c; /* Darker for dark mode nav */
            --nav-text: #cbd5e1;
            --nav-hover-bg: #2d3748;
            --nav-active-text: #fcd34d;
        }

        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e2e8f0; /* Tailwind gray-200 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8; /* Tailwind gray-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* Tailwind gray-500 */
        }
        /* Table styling */
        .node-table th, .node-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0; /* Tailwind gray-200 */
        }
        .node-table th {
            background-color: #f1f5f9; /* Tailwind slate-100 */
            font-weight: 600;
            color: #475569; /* Tailwind slate-600 */
            font-size: 0.875rem; /* sm text */
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .node-table tbody tr:hover {
            background-color: #f8fafc; /* Tailwind gray-50 */
        }
        .node-table tbody tr:last-child td {
            border-bottom: none;
        }
        /* Theme toggle button styling */
        #themeIcon {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--nav-text); /* Matches nav text color */
            transition: color 0.3s ease;
            z-index: 10; /* Ensure it's above other elements */
        }
    </style>
</head>
<body class="bg-[var(--bg-color)] text-[var(--text-color)] min-h-screen flex flex-col items-center">
    <button id="themeIcon">üåô</button>

    <!-- Navigation Bar -->
    <nav class="bg-[var(--nav-bg)] p-4 shadow-md flex justify-center relative w-full">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <div class="text-2xl font-bold text-[var(--nav-text)] mb-2 sm:mb-0">NoNet</div>
            <div class="flex space-x-4">
                <a href="/" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">Home</a>
                <a href="/dashboard" class="text-[var(--nav-active-text)] font-semibold hover:text-[var(--nav-text)] py-2 px-3 rounded-md transition duration-300 bg-[var(--nav-hover-bg)]">Dashboard</a>
                <a href="/map" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">Map</a>
                <a href="/about" class="text-[var(--nav-text)] font-semibold hover:text-[var(--nav-active-text)] py-2 px-3 rounded-md transition duration-300 hover:bg-[var(--nav-hover-bg)]">About</a>
            </div>
        </div>
    </nav>

    <!-- Header Section -->
    <header class="w-full max-w-6xl text-center mb-8 p-4 sm:p-6">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-700 mb-2 drop-shadow-lg">
            ESP32 Sensor & Anomaly Dashboard
        </h1>
        <p class="text-lg text-gray-600">Live monitoring and anomaly detection of environmental sensors</p>
    </header>

    <!-- Main Content Area -->
    <main class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-3 gap-6 p-4 sm:p-6">

        <!-- Overall Sensor Data Section (Left/Top) -->
        <section class="lg:col-span-2 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Overall Sensor Data (Average)</h2>
            <div id="overallSensorChart" class="w-full h-80 sm:h-96 bg-gray-50 rounded-lg border border-gray-200">
                <!-- Plotly chart will be rendered here -->
            </div>
            <div id="overallSensorMetrics" class="grid grid-cols-2 sm:grid-cols-3 gap-4 mt-6 text-center">
                <!-- Live metrics will be updated here by JavaScript -->
            </div>
        </section>

        <!-- Status & Last Update Section (Right/Top) -->
        <section class="lg:col-span-1 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200 flex flex-col justify-between">
            <div>
                <h2 class="text-2xl font-bold text-gray-800 mb-4">System Status</h2>
                <div class="flex items-center mb-4">
                    <span class="relative flex h-3 w-3 mr-3">
                        <span id="connectionStatusPulse" class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                        <span id="connectionStatusDot" class="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
                    </span>
                    <p id="connectionMessage" class="text-lg font-medium text-green-700">Connected to Backend</p>
                </div>
                <p class="text-md text-gray-600 mb-2">Last data update:</p>
                <p id="lastUpdateTime" class="text-lg font-semibold text-blue-600">N/A</p>
            </div>
            <div class="mt-6 pt-4 border-t border-gray-200">
                <h3 class="text-xl font-bold text-gray-800 mb-3">Active Nodes</h3>
                <div id="activeNodesList" class="max-h-40 overflow-y-auto pr-2">
                    <!-- Active nodes will be listed here by JavaScript -->
                    <p class="text-gray-500">No nodes detected yet...</p>
                </div>
            </div>
        </section>

        <!-- Overall Anomaly Data Section -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Overall Anomaly Scores (Average)</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div id="overallIsoScoreChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div id="overallRiverScoreChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div id="overallWarningLevelChart" class="w-full h-64 bg-gray-50 rounded-lg border border-gray-200"></div>
            </div>
            <div id="overallAnomalyMetrics" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mt-6 text-center">
                <!-- Live anomaly metrics will be updated here by JavaScript -->
            </div>
        </section>

        <!-- Current Node Data Table -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Current Node Data Table</h2>
            <div class="overflow-x-auto">
                <table id="nodeDataTable" class="min-w-full bg-white rounded-lg node-table">
                    <thead>
                        <tr>
                            <th>Node ID</th>
                            <th>Timestamp</th>
                            <th>MAC Address</th>
                            <th>Rain</th>
                            <th>Soil</th>
                            <th>Vibration (g)</th>
                            <th>Tilt (¬∞)</th>
                            <th>IF Score</th>
                            <th>HST Score</th>
                            <th>Warning Level</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be dynamically populated here -->
                        <tr><td colspan="10" class="text-center text-gray-500 py-4">No node data available.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Individual Node Data Section (Bottom) -->
        <section class="lg:col-span-3 bg-[var(--card-bg)] p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Individual Node Data & Anomaly Scores</h2>
            <div id="individualNodesContainer" class="">
                <!-- Individual node charts will be dynamically added here by JavaScript -->
                <div class="p-4 bg-gray-50 rounded-lg text-center text-gray-500 border border-gray-200">
                    No individual node data available yet.
                </div>
            </div>
        </section>

    </main>

    <!-- JavaScript for fetching data and updating charts -->
    <script>
        // Configuration for the data fetching
        const API_URL = '/api/live_data'; // Endpoint for your Flask backend
        const FETCH_INTERVAL_MS = 1000; // Fetch data every 1 second
        const MAX_DATA_POINTS = 60; // Keep last 60 seconds of data for charts

        // Data storage for overall sensor data
        let overallSensorData = {
            timestamps: [],
            rain: [],
            soil: [],
            vibration: [],
            iso_score: [],
            river_score: [],
            warning_level_numerical: []
        };

        // Object to store data for individual nodes, keyed by node ID
        let individualNodeData = {};

        // DOM elements
        const overallSensorChartDiv = document.getElementById('overallSensorChart');
        const overallSensorMetricsDiv = document.getElementById('overallSensorMetrics');
        const overallIsoScoreChartDiv = document.getElementById('overallIsoScoreChart');
        const overallRiverScoreChartDiv = document.getElementById('overallRiverScoreChart');
        const overallWarningLevelChartDiv = document.getElementById('overallWarningLevelChart');
        const overallAnomalyMetricsDiv = document.getElementById('overallAnomalyMetrics');
        const individualNodesContainer = document.getElementById('individualNodesContainer');
        const lastUpdateTimeSpan = document.getElementById('lastUpdateTime');
        const connectionStatusDot = document.getElementById('connectionStatusDot');
        const connectionStatusPulse = document.getElementById('connectionStatusPulse');
        const connectionMessage = document.getElementById('connectionMessage');
        const activeNodesListDiv = document.getElementById('activeNodesList');
        const nodeDataTableBody = document.querySelector('#nodeDataTable tbody');

        // Plotly chart instances
        let overallSensorChartInstance;
        let overallIsoScoreChartInstance;
        let overallRiverScoreChartInstance;
        let overallWarningLevelChartInstance;
        const individualChartInstances = {};

        /**
         * Initializes the overall sensor data chart using Plotly.js.
         */
        function initializeOverallSensorChart() {
            const layout = {
                title: {
                    text: 'Overall Sensor Trends',
                    font: { size: 18, color: '#334155' },
                    y: 0.99
                },
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    tickformat: '%H:%M:%S',
                    linecolor: '#cbd5e1',
                    linewidth: 1
                },
                yaxis: {
                    title: 'Value',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [0, 4095]
                },
                margin: { l: 50, r: 20, t: 50, b: 50 },
                hovermode: 'x unified',
                responsive: true,
                paper_bgcolor: 'var(--card-bg)',
                plot_bgcolor: 'var(--card-bg)',
                font: {
                    family: 'Inter, sans-serif',
                    color: 'var(--text-color)'
                },
                legend: {
                    x: 0, y: 1.15,
                    orientation: 'h',
                    bgcolor: 'rgba(255, 255, 255, 0)',
                    bordercolor: 'rgba(255, 255, 255, 0)'
                }
            };

            const data = [
                {
                    x: overallSensorData.timestamps,
                    y: overallSensorData.rain,
                    mode: 'lines',
                    name: 'Rain',
                    line: { color: '#3b82f6', width: 2 }
                },
                {
                    x: overallSensorData.timestamps,
                    y: overallSensorData.soil,
                    mode: 'lines',
                    name: 'Soil Moisture',
                    line: { color: '#22c55e', width: 2 }
                },
                {
                    x: overallSensorData.timestamps,
                    y: overallSensorData.vibration,
                    mode: 'lines',
                    name: 'Vibration (g)',
                    line: { color: '#ef4444', width: 2 }
                }
            ];

            Plotly.newPlot(overallSensorChartDiv, data, layout, { displayModeBar: false, responsive: true });
            overallSensorChartInstance = overallSensorChartDiv;
        }

        /**
         * Initializes the overall anomaly score charts using Plotly.js.
         */
        function initializeOverallAnomalyCharts() {
            const commonLayout = {
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    tickformat: '%H:%M:%S',
                    linecolor: '#cbd5e1',
                    linewidth: 1
                },
                margin: { l: 50, r: 20, t: 40, b: 50 },
                hovermode: 'x unified',
                responsive: true,
                paper_bgcolor: 'var(--card-bg)',
                plot_bgcolor: 'var(--card-bg)',
                font: {
                    family: 'Inter, sans-serif',
                    color: 'var(--text-color)'
                },
                legend: {
                    x: 0, y: 1.15,
                    orientation: 'h',
                    bgcolor: 'rgba(255, 255, 255, 0)',
                    bordercolor: 'rgba(255, 255, 255, 0)'
                }
            };

            const isoLayout = {
                ...commonLayout,
                title: { text: 'Overall Isolation Forest Score', font: { size: 16, color: '#334155' } },
                yaxis: {
                    title: 'Score',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [-0.5, 0.5]
                }
            };
            Plotly.newPlot(overallIsoScoreChartDiv, [{
                x: overallSensorData.timestamps,
                y: overallSensorData.iso_score,
                mode: 'lines',
                name: 'IF Score',
                line: { color: '#8b5cf6', width: 2 }
            }], isoLayout, { displayModeBar: false, responsive: true });
            overallIsoScoreChartInstance = overallIsoScoreChartDiv;

            const riverLayout = {
                ...commonLayout,
                title: { text: 'Overall HalfSpaceTrees Score', font: { size: 16, color: '#334155' } },
                yaxis: {
                    title: 'Score',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [0, 1]
                }
            };
            Plotly.newPlot(overallRiverScoreChartDiv, [{
                x: overallSensorData.timestamps,
                y: overallSensorData.river_score,
                mode: 'lines',
                name: 'HST Score',
                line: { color: '#ec4899', width: 2 }
            }], riverLayout, { displayModeBar: false, responsive: true });
            overallRiverScoreChartInstance = overallRiverScoreChartDiv;

            const warningLayout = {
                ...commonLayout,
                title: { text: 'Overall Ensemble Warning Level', font: { size: 16, color: '#334155' } },
                yaxis: {
                    title: 'Level',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [0.0, 2.0],
                }
            };
            Plotly.newPlot(overallWarningLevelChartDiv, [{
                x: overallSensorData.timestamps,
                y: overallSensorData.warning_level_numerical,
                mode: 'lines',
                name: 'Warning Level',
                line: { color: '#f97316', width: 2 }
            }], warningLayout, { displayModeBar: false, responsive: true });
            overallWarningLevelChartInstance = overallWarningLevelChartDiv;
        }

        /**
         * Updates the overall sensor data chart with new data.
         */
        function updateOverallSensorChart() {
            if (!overallSensorChartInstance) {
                initializeOverallSensorChart();
                return;
            }

            const update = {
                x: [[overallSensorData.timestamps[overallSensorData.timestamps.length - 1]],
                    [overallSensorData.timestamps[overallSensorData.timestamps.length - 1]],
                    [overallSensorData.timestamps[overallSensorData.timestamps.length - 1]]],
                y: [[overallSensorData.rain[overallSensorData.rain.length - 1]],
                    [overallSensorData.soil[overallSensorData.soil.length - 1]],
                    [overallSensorData.vibration[overallSensorData.vibration.length - 1]]]
            };

            Plotly.extendTraces(overallSensorChartInstance, update, [0, 1, 2], MAX_DATA_POINTS);
        }

        /**
         * Updates the overall anomaly charts with new data.
         */
        function updateOverallAnomalyCharts() {
            if (!overallIsoScoreChartInstance) {
                initializeOverallAnomalyCharts();
                return;
            }

            const updateIso = {
                x: [[overallSensorData.timestamps[overallSensorData.timestamps.length - 1]]],
                y: [[overallSensorData.iso_score[overallSensorData.iso_score.length - 1]]]
            };
            Plotly.extendTraces(overallIsoScoreChartInstance, updateIso, [0], MAX_DATA_POINTS);

            const updateRiver = {
                x: [[overallSensorData.timestamps[overallSensorData.timestamps.length - 1]]],
                y: [[overallSensorData.river_score[overallSensorData.river_score.length - 1]]]
            };
            Plotly.extendTraces(overallRiverScoreChartInstance, updateRiver, [0], MAX_DATA_POINTS);

            const updateWarning = {
                x: [[overallSensorData.timestamps[overallSensorData.timestamps.length - 1]]],
                y: [[overallSensorData.warning_level_numerical[overallSensorData.warning_level_numerical.length - 1]]]
            };
            Plotly.extendTraces(overallWarningLevelChartInstance, updateWarning, [0], MAX_DATA_POINTS);
        }


        /**
         * Updates the live metrics display for overall sensor data.
         */
        function updateOverallMetrics(latestData) {
            overallSensorMetricsDiv.innerHTML = `
                <div class="p-3 bg-blue-50 rounded-lg shadow-sm">
                    <p class="text-sm text-blue-700 font-semibold">Rain</p>
                    <p class="text-xl font-bold text-blue-900">${latestData.rain !== undefined ? latestData.rain.toFixed(0) : 'N/A'}</p>
                </div>
                <div class="p-3 bg-green-50 rounded-lg shadow-sm">
                    <p class="text-sm text-green-700 font-semibold">Soil Moisture</p>
                    <p class="text-xl font-bold text-green-900">${latestData.soil !== undefined ? latestData.soil.toFixed(0) : 'N/A'}</p>
                </div>
                <div class="p-3 bg-red-50 rounded-lg shadow-sm">
                    <p class="text-sm text-red-700 font-semibold">Vibration (g)</p>
                    <p class="text-xl font-bold text-red-900">${latestData.vibration !== undefined ? latestData.vibration.toFixed(3) : 'N/A'}g</p>
                </div>
            `;

            overallAnomalyMetricsDiv.innerHTML = `
                <div class="p-3 bg-violet-50 rounded-lg shadow-sm">
                    <p class="text-sm text-violet-700 font-semibold">IF Score</p>
                    <p class="text-xl font-bold text-violet-900">${latestData.iso_score !== undefined && latestData.iso_score !== null ? latestData.iso_score.toFixed(3) : 'N/A'}</p>
                </div>
                <div class="p-3 bg-pink-50 rounded-lg shadow-sm">
                    <p class="text-sm text-pink-700 font-semibold">HST Score</p>
                    <p class="text-xl font-bold text-pink-900">${latestData.river_score !== undefined && latestData.river_score !== null ? latestData.river_score.toFixed(3) : 'N/A'}</p>
                </div>
                <div class="p-3 bg-orange-50 rounded-lg shadow-sm">
                    <p class="text-sm text-orange-700 font-semibold">Warning Level</p>
                    <p class="text-xl font-bold text-orange-900">${latestData.warning_level_numerical !== undefined && latestData.warning_level_numerical !== null ? latestData.warning_level_numerical.toFixed(3) : 'N/A'}</p>
                </div>
            `;
        }

        /**
         * Initializes a chart for a specific individual node.
         */
        function initializeIndividualNodeChart(nodeId) {
            const chartDivId = `nodeChart_${nodeId}`;
            const isoChartDivId = `nodeIsoScoreChart_${nodeId}`;
            const riverChartDivId = `nodeRiverScoreChart_${nodeId}`;
            const warningChartDivId = `nodeWarningLevelChart_${nodeId}`;

            const chartDiv = document.getElementById(chartDivId);
            const isoChartDiv = document.getElementById(isoChartDivId);
            const riverChartDiv = document.getElementById(riverChartDivId);
            const warningChartDiv = document.getElementById(warningChartDivId);

            if (!chartDiv || !isoChartDiv || !riverChartDiv || !warningChartDiv) {
                console.error(`One or more chart divs not found for node: ${nodeId}`);
                return;
            }

            const commonLayout = {
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    tickformat: '%H:%M:%S',
                    linecolor: '#cbd5e1',
                    linewidth: 1
                },
                margin: { l: 50, r: 20, t: 40, b: 50 },
                hovermode: 'x unified',
                responsive: true,
                paper_bgcolor: 'var(--card-bg)',
                plot_bgcolor: 'var(--card-bg)',
                font: {
                    family: 'Inter, sans-serif',
                    color: 'var(--text-color)'
                },
                legend: {
                    x: 0, y: 1.15,
                    orientation: 'h',
                    bgcolor: 'rgba(255, 255, 255, 0)',
                    bordercolor: 'rgba(255, 255, 255, 0)'
                }
            };

            const sensorLayout = {
                ...commonLayout,
                title: { text: `Node ${nodeId} Sensor Data`, font: { size: 16, color: '#334155' } },
                yaxis: {
                    title: 'Value',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [0, 4095]
                }
            };
            Plotly.newPlot(chartDiv, [
                { x: individualNodeData[nodeId].timestamps, y: individualNodeData[nodeId].rain, mode: 'lines', name: 'Rain', line: { color: '#3b82f6', width: 2 } },
                { x: individualNodeData[nodeId].timestamps, y: individualNodeData[nodeId].soil, mode: 'lines', name: 'Soil Moisture', line: { color: '#22c55e', width: 2 } },
                { x: individualNodeData[nodeId].timestamps, y: individualNodeData[nodeId].vibration, mode: 'lines', name: 'Vibration (g)', line: { color: '#ef4444', width: 2 } }
            ], sensorLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`sensor_${nodeId}`] = chartDiv;

            const isoLayout = {
                ...commonLayout,
                title: { text: `Node ${nodeId} IF Score`, font: { size: 14, color: '#334155' } },
                yaxis: {
                    title: 'Score',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [-0.5, 0.5]
                }
            };
            Plotly.newPlot(isoChartDiv, [{
                x: individualNodeData[nodeId].timestamps,
                y: individualNodeData[nodeId].iso_score,
                mode: 'lines',
                name: 'IF Score',
                line: { color: '#8b5cf6', width: 2 }
            }], isoLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`iso_${nodeId}`] = isoChartDiv;

            const riverLayout = {
                ...commonLayout,
                title: { text: `Node ${nodeId} HST Score`, font: { size: 14, color: '#334155' } },
                yaxis: {
                    title: 'Score',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [0, 1]
                }
            };
            Plotly.newPlot(riverChartDiv, [{
                x: individualNodeData[nodeId].timestamps,
                y: individualNodeData[nodeId].river_score,
                mode: 'lines',
                name: 'HST Score',
                line: { color: '#ec4899', width: 2 }
            }], riverLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`river_${nodeId}`] = riverChartDiv;

            const warningLayout = {
                ...commonLayout,
                title: { text: `Node ${nodeId} Warning Level`, font: { size: 14, color: '#334155' } },
                yaxis: {
                    title: 'Level',
                    showgrid: true,
                    linecolor: '#cbd5e1',
                    linewidth: 1,
                    range: [0.0, 2.0],
                }
            };
            Plotly.newPlot(warningChartDiv, [{
                x: individualNodeData[nodeId].timestamps,
                y: individualNodeData[nodeId].warning_level_numerical,
                mode: 'lines',
                name: 'Warning Level',
                line: { color: '#f97316', width: 2 }
            }], warningLayout, { displayModeBar: false, responsive: true });
            individualChartInstances[`warning_${nodeId}`] = warningChartDiv;
        }

        /**
         * Updates the chart for a specific individual node with new data.
         */
        function updateIndividualNodeChart(nodeId) {
            const nodeData = individualNodeData[nodeId];

            if (individualChartInstances[`sensor_${nodeId}`]) {
                const updateSensor = {
                    x: [[nodeData.timestamps[nodeData.timestamps.length - 1]],
                        [nodeData.timestamps[nodeData.timestamps.length - 1]],
                        [nodeData.timestamps[nodeData.timestamps.length - 1]]],
                    y: [[nodeData.rain[nodeData.rain.length - 1]],
                        [nodeData.soil[nodeData.soil.length - 1]],
                        [nodeData.vibration[nodeData.vibration.length - 1]]]
                };
                Plotly.extendTraces(individualChartInstances[`sensor_${nodeId}`], updateSensor, [0, 1, 2], MAX_DATA_POINTS);
            } else {
                initializeIndividualNodeChart(nodeId);
            }

            if (individualChartInstances[`iso_${nodeId}`]) {
                const updateIso = {
                    x: [[nodeData.timestamps[nodeData.timestamps.length - 1]]],
                    y: [[nodeData.iso_score[nodeData.iso_score.length - 1]]]
                };
                Plotly.extendTraces(individualChartInstances[`iso_${nodeId}`], updateIso, [0], MAX_DATA_POINTS);
            }

            if (individualChartInstances[`river_${nodeId}`]) {
                const updateRiver = {
                    x: [[nodeData.timestamps[nodeData.timestamps.length - 1]]],
                    y: [[nodeData.river_score[nodeData.river_score.length - 1]]]
                };
                Plotly.extendTraces(individualChartInstances[`river_${nodeId}`], updateRiver, [0], MAX_DATA_POINTS);
            }

            if (individualChartInstances[`warning_${nodeId}`]) {
                const updateWarning = {
                    x: [[nodeData.timestamps[nodeData.timestamps.length - 1]]],
                    y: [[nodeData.warning_level_numerical[nodeData.warning_level_numerical.length - 1]]]
                };
                Plotly.extendTraces(individualChartInstances[`warning_${nodeId}`], updateWarning, [0], MAX_DATA_POINTS);
            }
        }

        /**
         * Manages the creation and removal of individual node display sections.
         */
        function manageIndividualNodeDisplays(currentNodes) {
            const currentNodeIds = Object.keys(currentNodes);
            const displayedNodeIds = new Set(Object.keys(individualNodeData));

            let gridClasses = 'grid gap-6';
            if (currentNodeIds.length === 1) {
                gridClasses += ' grid-cols-1 sm:grid-cols-1 lg:grid-cols-1';
            } else if (currentNodeIds.length === 2) {
                gridClasses += ' grid-cols-1 sm:grid-cols-2 lg:grid-cols-2';
            } else if (currentNodeIds.length >= 3) {
                gridClasses += ' grid-cols-1 sm:grid-cols-2 xl:grid-cols-3';
            }
            
            if (currentNodeIds.length > 0) {
                individualNodesContainer.className = gridClasses;
                const noDataMessage = individualNodesContainer.querySelector('.text-gray-500');
                if (noDataMessage) {
                    individualNodesContainer.innerHTML = '';
                }
            } else {
                individualNodesContainer.className = 'flex items-center justify-center h-64 w-full';
                individualNodesContainer.innerHTML = `<div class="p-4 bg-gray-50 rounded-lg text-center text-gray-500 border border-gray-200">No individual node data available yet.</div>`;
            }

            displayedNodeIds.forEach(nodeId => {
                if (!currentNodeIds.includes(nodeId)) {
                    const nodeCard = document.getElementById(`nodeCard_${nodeId}`);
                    if (nodeCard) nodeCard.remove();
                    delete individualNodeData[nodeId];
                    delete individualChartInstances[`sensor_${nodeId}`];
                    delete individualChartInstances[`iso_${nodeId}`];
                    delete individualChartInstances[`river_${nodeId}`];
                    delete individualChartInstances[`warning_${nodeId}`];
                }
            });

            currentNodeIds.forEach(nodeId => {
                if (!displayedNodeIds.has(nodeId)) {
                    individualNodeData[nodeId] = {
                        timestamps: [], rain: [], soil: [], vibration: [],
                        iso_score: [], river_score: [], warning_level_numerical: []
                    };

                    const nodeCard = document.createElement('div');
                    nodeCard.id = `nodeCard_${nodeId}`;
                    nodeCard.className = 'bg-[var(--card-bg)] p-4 rounded-lg shadow-md border border-gray-200';
                    nodeCard.innerHTML = `
                        <h3 class="text-xl font-bold text-gray-800 mb-3">Node ${nodeId}</h3>
                        <div id="nodeChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeIsoScoreChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeRiverScoreChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeWarningLevelChart_${nodeId}" class="w-full h-48 bg-gray-50 rounded-lg border border-gray-200 mb-4"></div>
                        <div id="nodeMetrics_${nodeId}" class="grid grid-cols-2 sm:grid-cols-3 gap-2 mt-4 text-center"></div>
                    `;
                    individualNodesContainer.appendChild(nodeCard);
                    initializeIndividualNodeChart(nodeId);
                }
                updateIndividualNodeMetrics(nodeId, currentNodes[nodeId]);
            });

            for (const key in individualChartInstances) {
                Plotly.relayout(individualChartInstances[key], { autosize: true });
            }
        }

        /**
         * Updates the live metrics display for an individual node.
         */
        function updateIndividualNodeMetrics(nodeId, latestData) {
            const nodeMetricsDiv = document.getElementById(`nodeMetrics_${nodeId}`);
            if (nodeMetricsDiv) {
                nodeMetricsDiv.innerHTML = `
                    <div class="p-2 bg-blue-50 rounded-md text-sm">
                        <p class="text-blue-700 font-semibold">Rain:</p>
                        <p class="text-blue-900 font-bold">${latestData.rain !== undefined ? latestData.rain.toFixed(0) : 'N/A'}</p>
                    </div>
                    <div class="p-2 bg-green-50 rounded-md text-sm">
                        <p class="text-green-700 font-semibold">Soil:</p>
                        <p class="text-green-900 font-bold">${latestData.soil !== undefined ? latestData.soil.toFixed(0) : 'N/A'}</p>
                    </div>
                    <div class="p-2 bg-red-50 rounded-md text-sm">
                        <p class="text-red-700 font-semibold">Vib (g):</p>
                        <p class="text-red-900 font-bold">${latestData.vibration !== undefined ? latestData.vibration.toFixed(3) : 'N/A'}g</p>
                    </div>
                    <div class="p-2 bg-orange-50 rounded-md text-sm">
                        <p class="text-orange-700 font-semibold">Tilt:</p>
                        <p class="text-orange-900 font-bold">${latestData.tilt !== undefined ? latestData.tilt.toFixed(1) : 'N/A'}¬∞</p>
                    </div>
                    <div class="p-2 bg-violet-50 rounded-md text-sm">
                        <p class="text-violet-700 font-semibold">IF Score:</p>
                        <p class="text-violet-900 font-bold">${latestData.iso_score !== undefined && latestData.iso_score !== null ? latestData.iso_score.toFixed(3) : 'N/A'}</p>
                    </div>
                    <div class="p-2 bg-pink-50 rounded-md text-sm">
                        <p class="text-pink-700 font-semibold">HST Score:</p>
                        <p class="text-pink-900 font-bold">${latestData.river_score !== undefined && latestData.river_score !== null ? latestData.river_score.toFixed(3) : 'N/A'}</p>
                    </div>
                    <div class="p-2 bg-orange-50 rounded-md text-sm">
                        <p class="text-orange-700 font-semibold">Warning:</p>
                        <p class="text-orange-900 font-bold">${latestData.warning_level_numerical !== undefined && latestData.warning_level_numerical !== null ? latestData.warning_level_numerical.toFixed(3) : 'N/A'}</p>
                    </div>
                `;
            }
        }

        /**
         * Updates the list of active nodes displayed on the dashboard.
         */
        function updateActiveNodesList(nodeIds) {
            if (nodeIds.length === 0) {
                activeNodesListDiv.innerHTML = '<p class="text-gray-500">No nodes detected yet...</p>';
            } else {
                activeNodesListDiv.innerHTML = nodeIds.map(id => `
                    <div class="flex items-center text-gray-700 py-1">
                        <span class="h-2 w-2 rounded-full bg-blue-400 mr-2"></span>
                        <span>Node ${id}</span>
                    </div>
                `).join('');
            }
        }

        /**
         * Updates the current data table with the latest information for each node.
         */
        function updateNodeDataTable(nodesData) {
            let tableHtml = '';
            const nodeIds = Object.keys(nodesData).sort();

            if (nodeIds.length === 0) {
                tableHtml = '<tr><td colspan="10" class="text-center text-gray-500 py-4">No node data available.</td></tr>';
            } else {
                nodeIds.forEach(nodeId => {
                    const node = nodesData[nodeId];
                    const timestamp = new Date(node.last_seen_by_flask).toLocaleTimeString();
                    tableHtml += `
                        <tr>
                            <td>${nodeId}</td>
                            <td>${timestamp}</td>
                            <td>${node.mac || 'N/A'}</td>
                            <td>${node.rain !== undefined ? node.rain.toFixed(0) : 'N/A'}</td>
                            <td>${node.soil !== undefined ? node.soil.toFixed(0) : 'N/A'}</td>
                            <td>${node.vibration !== undefined ? node.vibration.toFixed(3) : 'N/A'}</td>
                            <td>${node.tilt !== undefined ? node.tilt.toFixed(1) : 'N/A'}</td>
                            <td>${node.iso_score !== undefined && node.iso_score !== null ? node.iso_score.toFixed(3) : 'N/A'}</td>
                            <td>${node.river_score !== undefined && node.river_score !== null ? node.river_score.toFixed(3) : 'N/A'}</td>
                            <td>${node.warning_level_numerical !== undefined && node.warning_level_numerical !== null ? node.warning_level_numerical.toFixed(3) : 'N/A'}</td>
                        </tr>
                    `;
                });
            }
            nodeDataTableBody.innerHTML = tableHtml;
        }


        /**
         * Sets the connection status display.
         */
        function setConnectionStatus(isConnected, message) {
            if (isConnected) {
                connectionStatusDot.classList.remove('bg-red-500');
                connectionStatusDot.classList.add('bg-green-500');
                connectionStatusPulse.classList.add('animate-ping');
                connectionMessage.classList.remove('text-red-700');
                connectionMessage.classList.add('text-green-700');
            } else {
                connectionStatusDot.classList.remove('bg-green-500');
                connectionStatusDot.classList.add('bg-red-500');
                connectionStatusPulse.classList.remove('animate-ping');
                connectionMessage.classList.remove('text-green-700');
                connectionMessage.classList.add('text-red-700');
            }
            connectionMessage.textContent = message;
        }

        /**
         * Fetches live sensor data from the Flask backend API.
         */
        async function fetchSensorData() {
            try {
                const response = await fetch(API_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                setConnectionStatus(true, 'Connected to Backend');
                lastUpdateTimeSpan.textContent = new Date().toLocaleTimeString();

                const timestamp = new Date(data.timestamp);
                if(data.overall_data && data.overall_data.rain !== null) {
                    overallSensorData.timestamps.push(timestamp);
                    overallSensorData.rain.push(data.overall_data.rain);
                    overallSensorData.soil.push(data.overall_data.soil);
                    overallSensorData.vibration.push(data.overall_data.vibration);
                    overallSensorData.iso_score.push(data.overall_data.iso_score);
                    overallSensorData.river_score.push(data.overall_data.river_score);
                    overallSensorData.warning_level_numerical.push(data.overall_data.warning_level_numerical);

                    if (overallSensorData.timestamps.length > MAX_DATA_POINTS) {
                        overallSensorData.timestamps.shift();
                        overallSensorData.rain.shift();
                        overallSensorData.soil.shift();
                        overallSensorData.vibration.shift();
                        overallSensorData.iso_score.shift();
                        overallSensorData.river_score.shift();
                        overallSensorData.warning_level_numerical.shift();
                    }

                    updateOverallSensorChart();
                    updateOverallAnomalyCharts();
                    updateOverallMetrics(data.overall_data);
                }

                manageIndividualNodeDisplays(data.nodes);
                updateNodeDataTable(data.nodes);
                const activeNodeIds = Object.keys(data.nodes);
                
                for (const nodeId in data.nodes) {
                    const nodeTimestamp = new Date(data.nodes[nodeId].last_seen_by_flask);
                    const nodeData = data.nodes[nodeId];

                    if (!individualNodeData[nodeId]) {
                        individualNodeData[nodeId] = {
                            timestamps: [], rain: [], soil: [], vibration: [],
                            iso_score: [], river_score: [], warning_level_numerical: []
                        };
                    }

                    individualNodeData[nodeId].timestamps.push(nodeTimestamp);
                    individualNodeData[nodeId].rain.push(nodeData.rain);
                    individualNodeData[nodeId].soil.push(nodeData.soil);
                    individualNodeData[nodeId].vibration.push(nodeData.vibration);
                    individualNodeData[nodeId].iso_score.push(nodeData.iso_score);
                    individualNodeData[nodeId].river_score.push(nodeData.river_score);
                    individualNodeData[nodeId].warning_level_numerical.push(nodeData.warning_level_numerical);

                    if (individualNodeData[nodeId].timestamps.length > MAX_DATA_POINTS) {
                        Object.keys(individualNodeData[nodeId]).forEach(key => individualNodeData[nodeId][key].shift());
                    }
                    updateIndividualNodeChart(nodeId);
                    updateIndividualNodeMetrics(nodeId, nodeData);
                }
                updateActiveNodesList(activeNodeIds);

            } catch (error) {
                console.error('Error fetching sensor data:', error);
                setConnectionStatus(false, 'Disconnected from Backend');
                lastUpdateTimeSpan.textContent = 'Error fetching data';
            }
        }

        // Initialize charts when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeOverallSensorChart();
            initializeOverallAnomalyCharts();
            fetchSensorData();
            setInterval(fetchSensorData, FETCH_INTERVAL_MS);

            if (document.body.classList.contains("dark-mode")) {
                themeIcon.textContent = "‚òÄÔ∏è";
            } else {
                themeIcon.textContent = "üåô";
            }

            themeIcon.addEventListener("click", function () {
                document.body.classList.toggle("dark-mode");
                themeIcon.textContent = document.body.classList.contains("dark-mode") ? "‚òÄÔ∏è" : "üåô";
            });

            window.onresize = function() {
                if (overallSensorChartInstance) Plotly.relayout(overallSensorChartInstance, { autosize: true });
                if (overallIsoScoreChartInstance) Plotly.relayout(overallIsoScoreChartInstance, { autosize: true });
                if (overallRiverScoreChartInstance) Plotly.relayout(overallRiverScoreChartInstance, { autosize: true });
                if (overallWarningLevelChartInstance) Plotly.relayout(overallWarningLevelChartInstance, { autosize: true });
                for (const key in individualChartInstances) {
                    Plotly.relayout(individualChartInstances[key], { autosize: true });
                }
            };
        });
    </script>
</body>
</html>
